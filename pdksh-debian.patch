diff -urN pdksh-5.2.14.org/Makefile.in pdksh-5.2.14/Makefile.in
--- pdksh-5.2.14.org/Makefile.in	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/Makefile.in	Mon Feb 26 12:19:09 2001
@@ -16,7 +16,7 @@
 LIBS = @LIBS@
 
 CPPFLAGS = @CPPFLAGS@
-CFLAGS = @CFLAGS@
+CFLAGS = @CFLAGS@ -DDEBIAN
 LDSTATIC = @LDSTATIC@
 LDFLAGS = @LDFLAGS@
 
diff -urN pdksh-5.2.14.org/alloc.c pdksh-5.2.14/alloc.c
--- pdksh-5.2.14.org/alloc.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/alloc.c	Mon Feb 26 12:17:11 2001
@@ -110,6 +110,13 @@
 	Block  *block;
 	struct {int _;} junk;	/* alignment */
 	double djunk;		/* alignment */
+#ifdef DEBIAN /* patch from RedHat */
+#ifdef __ia64__
+       /* IA64 requires 16 byte alignment for some objects, so make
+        * this the minimum allocation size */
+	char    ajunk[16];
+#endif
+#endif
 };
 
 struct Block {
diff -urN pdksh-5.2.14.org/c_ksh.c pdksh-5.2.14/c_ksh.c
--- pdksh-5.2.14.org/c_ksh.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/c_ksh.c	Mon Feb 26 12:17:11 2001
@@ -1208,6 +1208,7 @@
 						builtin_opt.optarg);
 					return 1;
 				}
+				break;		
 			  case '?':
 				return 1;
 			}
diff -urN pdksh-5.2.14.org/edit.c pdksh-5.2.14/edit.c
--- pdksh-5.2.14.org/edit.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/edit.c	Mon Feb 26 12:17:11 2001
@@ -15,6 +15,9 @@
 # include <sys/stream.h>	/* needed for <sys/ptem.h> */
 # include <sys/ptem.h>		/* needed for struct winsize */
 #endif /* OS_SCO */
+#ifdef DEBIAN
+#include <sys/ioctl.h>
+#endif /* DEBIAN */
 #include <ctype.h>
 #include "ksh_stat.h"
 
@@ -552,7 +555,11 @@
 {
 	char *toglob;
 	char **words;
+#ifndef DEBIAN 
 	int nwords;
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	int nwords, i, idx, escaping;
+#endif /* DEBIAN */
 	XPtrV w;
 	struct source *s, *sold;
 
@@ -561,6 +568,22 @@
 
 	toglob = add_glob(str, slen);
 
+#ifdef DEBIAN /* patch from OpenBSD */
+	/* remove all escaping backward slashes */
+	escaping = 0;
+	for(i = 0, idx = 0; toglob[i]; i++) {
+		if (toglob[i] == '\\' && !escaping) {
+			escaping = 1;
+			continue;
+		}
+
+		toglob[idx] = toglob[i];
+		idx++;
+		if (escaping) escaping = 0;
+	}
+	toglob[idx] = '\0';
+
+#endif /* DEBIAN */
 	/*
 	 * Convert "foo*" (toglob) to an array of strings (words)
 	 */
@@ -766,11 +789,23 @@
 	/* Keep going backwards to start of word (has effect of allowing
 	 * one blank after the end of a word)
 	 */
+#ifndef DEBIAN
 	for (; start > 0 && IS_WORDC(buf[start - 1]); start--)
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	for (; (start > 0 && IS_WORDC(buf[start - 1]))
+		|| (start > 1 && buf[start-2] == '\\'); start--)
+#endif /* DEBIAN */
 		;
 	/* Go forwards to end of word */
+#ifndef DEBIAN
 	for (end = start; end < buflen && IS_WORDC(buf[end]); end++)
 		;
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	for (end = start; end < buflen && IS_WORDC(buf[end]); end++) {
+		if (buf[end] == '\\' && (end+1) < buflen && buf[end+1] == ' ')
+			end++;
+	}
+#endif /* DEBIAN */
 
 	if (is_commandp) {
 		int iscmd;
@@ -1037,4 +1072,42 @@
 	Xfree(xs, xp);
 }
 
+#ifdef DEBIAN /* patch from OpenBSD */  
+/*
+ * if argument string contains any special characters, they will
+ * be escaped and the result will be put into edit buffer by
+ * keybinding-specific function
+ */
+int
+x_escape(s, len, putbuf_func)
+	const char *s;
+	size_t len;
+	int putbuf_func ARGS((const char *s, size_t len));
+{
+	size_t add, wlen;
+	const char *ifs = str_val(local("IFS", 0));
+	int rval=0;
+
+	for (add = 0, wlen = len; wlen - add > 0; add++) {
+		if (strchr("\\$(){}*&;|<>\"'", s[add]) || strchr(ifs, s[add])) {
+			if (putbuf_func(s, add) != 0) {
+				rval = -1;
+				break;
+			}
+
+			putbuf_func("\\", 1);
+			putbuf_func(&s[add], 1);
+
+			add++;
+			wlen -= add;
+			s += add;
+			add = -1; /* after the increment it will go to 0 */
+		}
+	}
+	if (wlen > 0 && rval == 0)
+		rval = putbuf_func(s, wlen);
+
+	return (rval);
+}
+#endif /* DEBIAN */
 #endif /* EDIT */
diff -urN pdksh-5.2.14.org/edit.h pdksh-5.2.14/edit.h
--- pdksh-5.2.14.org/edit.h	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/edit.h	Mon Feb 26 12:17:11 2001
@@ -55,6 +55,9 @@
 int	x_longest_prefix ARGS((int nwords, char *const *words));
 int	x_basename ARGS((const char *s, const char *se));
 void	x_free_words ARGS((int nwords, char **words));
+#ifdef DEBIAN /* patch from OpenBSD */ 
+int	x_escape ARGS((const char *, size_t, int (*)(const char *s, size_t len)));
+#endif /* DEBIAN */
 /* emacs.c */
 int 	x_emacs		ARGS((char *buf, size_t len));
 void 	x_init_emacs	ARGS((void));
diff -urN pdksh-5.2.14.org/emacs.c pdksh-5.2.14/emacs.c
--- pdksh-5.2.14.org/emacs.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/emacs.c	Mon Feb 26 12:17:11 2001
@@ -138,6 +138,10 @@
 static int	x_e_getc    ARGS((void));
 static void	x_e_putc    ARGS((int c));
 static void	x_e_puts    ARGS((const char *s));
+#ifdef DEBIAN /* patch from OpenBSD */ 
+static int	x_comment   ARGS((int c));
+static int	x_emacs_putbuf	ARGS((const char *s, size_t len));
+#endif /* DEBIAN */
 static int	x_fold_case ARGS((int c));
 static char	*x_lastcp ARGS((void));
 static void	do_complete ARGS((int flags, Comp_type type));
@@ -269,6 +273,9 @@
 	{ XFUNC_transpose,		0, CTRL('T') },
 #endif
 	{ XFUNC_complete,		1, CTRL('[') },
+#ifdef DEBIAN /* patch from OpenBSD */ 
+	{ XFUNC_complete,		0, CTRL('I') },
+#endif /* DEBIAN */
         { XFUNC_comp_list,		1,	'='  },
 	{ XFUNC_enumerate,		1,	'?'  },
         { XFUNC_expand,			1,	'*'  },
@@ -313,6 +320,9 @@
 	 * entries.
 	 */
         { XFUNC_meta2,			1,	'['  },
+#ifdef DEBIAN  /* patch from OpenBSD */ 
+        { XFUNC_meta2,			1,	'O'  },
+#endif /* DEBIAN */
 	{ XFUNC_prev_com,		2,	'A'  },
 	{ XFUNC_next_com,		2,	'B'  },
 	{ XFUNC_mv_forw,		2,	'C'  },
@@ -468,6 +478,23 @@
 	return 0;
 }
 
+#ifdef DEBIAN  /* patch from OpenBSD */ 
+/*
+ * this is used for x_escape() in do_complete()
+ */
+static int
+x_emacs_putbuf(s, len)
+	const char *s;
+	size_t len;
+{
+	int rval;
+
+	if ((rval = x_do_ins(s, len)) != 0)
+		return (rval);
+	return (rval);
+}
+
+#endif /* DEBIAN */
 static int
 x_del_back(c)
 	int c;
@@ -1485,7 +1512,11 @@
 		for (j = 0; j < X_TABSZ; j++)
 			x_tab[i][j] = XFUNC_error;
 	for (i = 0; i < NELEM(x_defbindings); i++)
+#ifndef DEBIAN
 		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+		x_tab[(unsigned char)x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
+#endif /* DEBIAN */
 			= x_defbindings[i].xdb_func;
 
 	x_atab = (char *(*)[X_TABSZ]) alloc(sizeofN(*x_atab, X_NTABS), AEDIT);
@@ -1828,8 +1859,13 @@
 			if (nlen > 0) {
 				x_goto(xbuf + start);
 				x_delete(end - start, FALSE);
+#ifndef DEBIAN
 				words[0][nlen] = '\0';
 				x_ins(words[0]);
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+				x_escape(words[0], nlen, x_emacs_putbuf);
+				x_adjust();
+#endif /* DEBIAN */
 				/* If single match is not a directory, add a
 				 * space to the end...
 				 */
diff -urN pdksh-5.2.14.org/io.c pdksh-5.2.14/io.c
--- pdksh-5.2.14.org/io.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/io.c	Mon Feb 26 12:17:15 2001
@@ -516,6 +516,14 @@
 	tp->name = path = (char *) &tp[1];
 	tp->shf = (struct shf *) 0;
 	tp->type = type;
+#ifdef DEBIAN  /* based on patch from OpenBSD */ 
+	shf_snprintf(path, len, "%s/kshXXXXXX", dir);
+	fd = mkstemp(path);
+	if (fd >= 0)
+		tp->shf = shf_fdopen(fd, SHF_WR, (struct shf *) 0);
+	if (fd >= 0)
+		fchmod(fd, 0600);	
+#else /* DEBIAN */
 	while (1) {
 		/* Note that temp files need to fit 8.3 DOS limits */
 		shf_snprintf(path, len, "%s/sh%05u.%03x",
@@ -542,6 +550,7 @@
 			break;
 	}
 	tp->next = NULL;
+#endif /* DEBIAN */
 	tp->pid = procpid;
 
 	tp->next = *tlist;
diff -urN pdksh-5.2.14.org/vi.c pdksh-5.2.14/vi.c
--- pdksh-5.2.14.org/vi.c	Mon Feb 26 12:16:47 2001
+++ pdksh-5.2.14/vi.c	Mon Feb 26 12:17:19 2001
@@ -63,6 +63,9 @@
 static void	vi_pprompt ARGS((int full));
 static void	vi_error ARGS((void));
 static void	vi_macro_reset ARGS((void));
+#ifdef DEBIAN   /* patch from OpenBSD */ 
+static int	x_vi_putbuf	ARGS((const char *s, size_t len));
+#endif /* DEBIAN */
 
 #define C_	0x1		/* a valid command that isn't a M_, E_, U_ */
 #define M_	0x2		/* movement command (h, l, etc.) */
@@ -1470,6 +1473,19 @@
 	holdlen = 0;
 }
 
+#ifdef DEBIAN /* patch from OpenBSD */ 
+/*
+ * this is used for calling x_escape() in complete_word()
+ */
+static int
+x_vi_putbuf(s, len)
+	const char *s;
+	size_t len;
+{
+	return putbuf(s, len, 0);
+}
+
+#endif /* DEBIAN */
 static int
 putbuf(buf, len, repl)
 	const char *buf;
@@ -1965,7 +1981,11 @@
 	del_range(start, end);
 	es->cursor = start;
 	for (i = 0; i < nwords; ) {
+#ifndef DEBIAN
 		if (putbuf(words[i], (int) strlen(words[i]), 0) != 0) {
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+		if (x_escape(words[i], strlen(words[i]), x_vi_putbuf) != 0) {
+#endif /* DEBIAN */
 			rval = -1;
 			break;
 		}
@@ -2068,9 +2088,18 @@
 	buf = save_edstate(es);
 	del_range(start, end);
 	es->cursor = start;
+#ifndef DEBIAN
 	if (putbuf(match, match_len, 0) != 0)
 		rval = -1;
 	else if (is_unique) {
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+
+	/* escape all shell-sensitive characters and put the result into
+	 * command buffer */
+	rval = x_escape(match, match_len, x_vi_putbuf);
+
+	if (rval == 0 && is_unique) {
+#endif /* DEBIAN */
 		/* If exact match, don't undo.  Allows directory completions
 		 * to be used (ie, complete the next portion of the path).
 		 */
