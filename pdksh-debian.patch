--- pdksh-5.2.14.orig/.cvsignore
+++ pdksh-5.2.14/.cvsignore
@@ -0,0 +1,12 @@
+config.log
+config.h
+config.cache
+Makefile
+a.out
+config.status
+stamp-h
+emacs.out
+siglist.out
+ksh
+ksh.1
+build-stamp
--- pdksh-5.2.14.orig/alloc.c
+++ pdksh-5.2.14/alloc.c
@@ -1,3 +1,5 @@
+#ifndef DEBIAN
+
 /*
  * area-based allocation built on malloc/free
  */
@@ -110,6 +112,13 @@
 	Block  *block;
 	struct {int _;} junk;	/* alignment */
 	double djunk;		/* alignment */
+#ifdef DEBIAN /* patch from RedHat */
+#ifdef __ia64__
+       /* IA64 requires 16 byte alignment for some objects, so make
+        * this the minimum allocation size */
+	char    ajunk[16];
+#endif
+#endif
 };
 
 struct Block {
@@ -282,7 +291,9 @@
 	 * working (as it assumes size < ICELLS means it is not
 	 * a `large object').
 	 */
-	if (oldcells > ICELLS && cells > ICELLS) {
+	if (oldcells > ICELLS && cells > ICELLS 
+	    && ((dp-2)->block->last == dp+oldcells) /* don't destroy blocks which have grown! */
+	   ) {
 		Block *bp = (dp-2)->block;
 		Block *nbp;
 		/* Saved in case realloc fails.. */
@@ -332,7 +343,7 @@
 	 * (need to check that cells < ICELLS so we don't make an
 	 * object a `large' - that would mess everything up).
 	 */
-	if (dp && cells > oldcells && cells <= ICELLS) {
+	if (dp && cells > oldcells) {
 		Cell *fp, *fpp;
 		Block *bp = (dp-2)->block;
 		int need = cells - oldcells - NOBJECT_FIELDS;
@@ -363,7 +374,7 @@
 	 * it to malloc...)
 	 * Note: this also handles cells == oldcells (a no-op).
 	 */
-	if (dp && cells <= oldcells && oldcells <= ICELLS) {
+	if (dp && cells <= oldcells) {
 		int split;
 
 		split = oldcells - cells;
@@ -411,7 +422,9 @@
 
 	/* If this is a large object, just free it up... */
 	/* Release object... */
-	if ((dp-1)->size > ICELLS) {
+	if ((dp-1)->size > ICELLS
+	    && (bp->last == dp + (dp-1)->size) /* don't free non-free blocks which have grown! */
+	   ) {
 		ablockfree(bp, ap);
 		ACHECK(ap);
 		return;
@@ -774,3 +787,127 @@
 # endif /* TEST_ALLOC */
 
 #endif /* MEM_DEBUG */
+
+#else /* DEBIAN */ /* patch from OpenBSD */
+
+/*	$OpenBSD: alloc.c,v 1.6 2003/08/05 20:52:27 millert Exp $	*/
+/*
+ * Copyright (c) 2002 Marc Espie.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
+ * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * area-based allocation built on malloc/free
+ */
+
+#include "sh.h"
+
+struct link {
+	struct link *prev;
+	struct link *next;
+};
+
+Area *
+ainit(Area *ap)
+{
+	ap->freelist = NULL;
+	return ap;
+}
+
+void
+afreeall(Area *ap)
+{
+	struct link *l, *l2;
+
+	for (l = ap->freelist; l != NULL; l = l2) {
+		l2 = l->next;
+		free(l);
+	}
+	ap->freelist = NULL;
+}
+
+#define L2P(l)	( (void *)(((char *)(l)) + sizeof(struct link)) )
+#define P2L(p)	( (struct link *)(((char *)(p)) - sizeof(struct link)) )
+
+void *
+alloc(size_t size, Area *ap)
+{
+	struct link *l;
+
+	l = malloc(size + sizeof(struct link));
+	if (l == NULL)
+		internal_errorf(1, "unable to allocate memory");
+	l->next = ap->freelist;
+	l->prev = NULL;
+	if (ap->freelist)
+		ap->freelist->prev = l;
+	ap->freelist = l;
+
+	return L2P(l);
+}
+
+void *
+aresize(void *ptr, size_t size, Area *ap)
+{
+	struct link *l, *l2, *lprev, *lnext;
+
+	if (ptr == NULL)
+		return alloc(size, ap);
+
+	l = P2L(ptr);
+	lprev = l->prev;
+	lnext = l->next;
+
+	l2 = realloc(l, size+sizeof(struct link));
+	if (l2 == NULL)
+		internal_errorf(1, "unable to allocate memory");
+	if (lprev)
+	    lprev->next = l2;
+	else
+	    ap->freelist = l2;
+	if (lnext)
+	    lnext->prev = l2;
+
+	return L2P(l2);
+}
+
+void
+afree(void *ptr, Area *ap)
+{
+	struct link *l;
+
+	if (!ptr)
+		return;
+
+	l = P2L(ptr);
+
+	if (l->prev)
+		l->prev->next = l->next;
+	else
+		ap->freelist = l->next;
+	if (l->next)
+		l->next->prev = l->prev;
+
+	free(l);
+}
+#endif /* DEBIAN */
--- pdksh-5.2.14.orig/c_ksh.c
+++ pdksh-5.2.14/c_ksh.c
@@ -1110,13 +1110,14 @@
 			return 1;
 		}
 	wp += builtin_opt.optind;
-	if (!*wp)
+	if (!*wp) {
 		if (j_jobs((char *) 0, flag, nflag))
 			rv = 1;
-	else
+	} else {
 		for (; *wp; wp++)
 			if (j_jobs(*wp, flag, nflag))
 				rv = 1;
+	}
 	return rv;
 }
 
@@ -1208,6 +1209,7 @@
 						builtin_opt.optarg);
 					return 1;
 				}
+				break;		
 			  case '?':
 				return 1;
 			}
--- pdksh-5.2.14.orig/c_sh.c
+++ pdksh-5.2.14/c_sh.c
@@ -422,7 +422,8 @@
 c_eval(wp)
 	char **wp;
 {
-	register struct source *s;
+	register struct source *s,*olds=source;
+	int retval;
 
 	if (ksh_getopt(wp, &builtin_opt, null) == '?')
 		return 1;
@@ -456,7 +457,9 @@
 		exstat = subst_exstat;
 	}
 
-	return shell(s, FALSE);
+	retval=shell(s, FALSE);
+	source=olds;
+	return retval;
 }
 
 int
@@ -643,6 +646,7 @@
 		for (wp = l->argv; (*wp++ = *owp++) != NULL; )
 			;
 	}
+#ifndef DEBIAN
 	/* POSIX says set exit status is 0, but old scripts that use
 	 * getopt(1), use the construct: set -- `getopt ab:c "$@"`
 	 * which assumes the exit value set will be that of the ``
@@ -650,6 +654,12 @@
 	 * if there are no command substitutions).
 	 */
 	return Flag(FPOSIX) ? 0 : subst_exstat;
+#else 
+	/* On Debian we always want set to return 0 like ksh93 does.
+	 * See: Bug#118476.
+	 */ 
+	return 0;
+#endif /* DEBIAN */
 }
 
 int
@@ -844,7 +854,7 @@
 			 * keeps them open).
 			 */
 #ifdef KSH
-			if (i > 2 && e->savefd[i])
+			if (!Flag(FSH) &&i > 2 && e->savefd[i])
 				fd_clexec(i);
 #endif /* KSH */
 		}
--- pdksh-5.2.14.orig/c_test.c
+++ pdksh-5.2.14/c_test.c
@@ -124,10 +124,10 @@
 	te.pos.wp = wp + 1;
 	te.wp_end = wp + argc;
 
-	/* 
+	/*
 	 * Handle the special cases from POSIX.2, section 4.62.4.
-	 * Implementation of all the rules isn't necessary since 
-	 * our parser does the right thing for the ommited steps.
+	 * Implementation of all the rules isn't necessary since
+	 * our parser does the right thing for the omitted steps.
 	 */
 	if (argc <= 5) {
 		char **owp = wp;
@@ -238,7 +238,7 @@
 			if (not)
 				res = !res;
 		}
-		return res; 
+		return res;
 	  case TO_FILRD: /* -r */
 		return test_eaccess(opnd1, R_OK) == 0;
 	  case TO_FILWR: /* -w */
@@ -456,10 +456,12 @@
 	}
 #endif /* !HAVE_DEV_FD */
 
-	/* On most (all?) unixes, access() says everything is executable for
+	res = eaccess(path, mode);
+	/*
+	 * On most (all?) unixes, access() says everything is executable for
 	 * root - avoid this on files by using stat().
 	 */
-	if ((mode & X_OK) && ksheuid == 0) {
+	if (res == 0 && ksheuid == 0 && (mode & X_OK)) {
 		struct stat statb;
 
 		if (stat(path, &statb) < 0)
@@ -469,13 +471,7 @@
 		else
 			res = (statb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))
 				? 0 : -1;
-		/* Need to check other permissions?  If so, use access() as
-		 * this will deal with root on NFS.
-		 */
-		if (res == 0 && (mode & (R_OK|W_OK)))
-			res = eaccess(path, mode);
-	} else
-		res = eaccess(path, mode);
+	}
 
 	return res;
 }
--- pdksh-5.2.14.orig/c_ulimit.c
+++ pdksh-5.2.14/c_ulimit.c
@@ -111,6 +111,9 @@
 #ifdef RLIMIT_SWAP
 		{ "swap(kbytes)", RLIMIT_SWAP, RLIMIT_SWAP, 1024, 'w' },
 #endif
+#ifdef RLIMIT_LOCKS
+		{ "flocks", RLIMIT, RLIMIT_LOCKS, RLIMIT_LOCKS, -1, 'L' },
+#endif
 		{ (char *) 0 }
 	    };
 	static char	options[3 + NELEM(limits)];
@@ -189,7 +192,16 @@
 		for (l = limits; l->name; l++) {
 #ifdef HAVE_SETRLIMIT
 			if (l->which == RLIMIT) {
-				getrlimit(l->gcmd, &limit);
+				int getreturn;
+
+				getreturn=getrlimit(l->gcmd, &limit);
+				if ( getreturn < 0 ) {
+					if ( ( errno == EINVAL ) &&
+					     ( l->gcmd == RLIMIT_LOCKS ) ) {
+						limit.rlim_cur = RLIM_INFINITY;
+						limit.rlim_max = RLIM_INFINITY;
+					}
+				}
 				if (how & SOFT)
 					val = limit.rlim_cur;
 				else if (how & HARD)
@@ -227,9 +239,14 @@
 			if (setrlimit(l->scmd, &limit) < 0) {
 				if (errno == EPERM)
 					bi_errorf("exceeds allowable limit");
-				else
+				else {
+					if ( ( errno == EINVAL ) &&
+					     ( l->scmd == RLIMIT_LOCKS ) ) {
+						bi_errorf("unable to set it on the current kernel");
+					} else
 					bi_errorf("bad limit: %s",
 						strerror(errno));
+				}
 				return 1;
 			}
 		} else {
--- pdksh-5.2.14.orig/edit.c
+++ pdksh-5.2.14/edit.c
@@ -15,6 +15,9 @@
 # include <sys/stream.h>	/* needed for <sys/ptem.h> */
 # include <sys/ptem.h>		/* needed for struct winsize */
 #endif /* OS_SCO */
+#ifdef DEBIAN
+#include <sys/ioctl.h>
+#endif /* DEBIAN */
 #include <ctype.h>
 #include "ksh_stat.h"
 
@@ -552,7 +555,11 @@
 {
 	char *toglob;
 	char **words;
+#ifndef DEBIAN 
 	int nwords;
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	int nwords, i, idx, escaping;
+#endif /* DEBIAN */
 	XPtrV w;
 	struct source *s, *sold;
 
@@ -561,6 +568,22 @@
 
 	toglob = add_glob(str, slen);
 
+#ifdef DEBIAN /* patch from OpenBSD */
+	/* remove all escaping backward slashes */
+	escaping = 0;
+	for(i = 0, idx = 0; toglob[i]; i++) {
+		if (toglob[i] == '\\' && !escaping) {
+			escaping = 1;
+			continue;
+		}
+
+		toglob[idx] = toglob[i];
+		idx++;
+		if (escaping) escaping = 0;
+	}
+	toglob[idx] = '\0';
+
+#endif /* DEBIAN */
 	/*
 	 * Convert "foo*" (toglob) to an array of strings (words)
 	 */
@@ -722,7 +745,12 @@
 	return nwords;
 }
 
+#ifndef DEBIAN
 #define IS_WORDC(c)	!(ctype(c, C_LEX1) || (c) == '\'' || (c) == '"')
+#else /* patch from OpenBSD */
+#define IS_WORDC(c)	!( ctype(c, C_LEX1) || (c) == '\'' || (c) == '"'  \
+			    || (c) == '`' || (c) == '=' || (c) == ':' )
+#endif
 
 static int
 x_locate_word(buf, buflen, pos, startp, is_commandp)
@@ -747,11 +775,23 @@
 	/* Keep going backwards to start of word (has effect of allowing
 	 * one blank after the end of a word)
 	 */
+#ifndef DEBIAN
 	for (; start > 0 && IS_WORDC(buf[start - 1]); start--)
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	for (; (start > 0 && IS_WORDC(buf[start - 1]))
+		|| (start > 1 && buf[start-2] == '\\'); start--)
+#endif /* DEBIAN */
 		;
 	/* Go forwards to end of word */
+#ifndef DEBIAN
 	for (end = start; end < buflen && IS_WORDC(buf[end]); end++)
 		;
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+	for (end = start; end < buflen && IS_WORDC(buf[end]); end++) {
+		if (buf[end] == '\\' && (end+1) < buflen)
+			end++;
+	}
+#endif /* DEBIAN */
 
 	if (is_commandp) {
 		int iscmd;
@@ -759,7 +799,11 @@
 		/* Figure out if this is a command */
 		for (p = start - 1; p >= 0 && isspace(buf[p]); p--)
 			;
+#ifndef DEBIAN
 		iscmd = p < 0 || strchr(";|&()", buf[p]);
+#else /* DEBIAN */ /* patch from OpenBSD */		
+		iscmd = p < 0 || strchr(";|&()`", buf[p]);
+#endif
 		if (iscmd) {
 			/* If command has a /, path, etc. is not searched;
 			 * only current directory is searched, which is just
@@ -961,6 +1005,9 @@
 {
 	const char *sp, *p;
 	char *xp;
+#ifdef DEBIAN /* patch from OpenBSD */
+	int staterr;
+#endif /* DEBIAN */	
 	int pathlen;
 	int patlen;
 	int oldsize, newsize, i, j;
@@ -995,13 +1042,23 @@
 		memcpy(xp, pat, patlen);
 
 		oldsize = XPsize(*wp);
+#ifndef DEBIAN		
 		glob_str(Xstring(xs, xp), wp, 0);
+#else /* DEBIAN */ /* patch from OpenBSD */
+		glob_str(Xstring(xs, xp), wp, 1); /* mark dirs */
+#endif		
 		newsize = XPsize(*wp);
 
 		/* Check that each match is executable... */
 		words = (char **) XPptrv(*wp);
 		for (i = j = oldsize; i < newsize; i++) {
+#ifndef DEBIAN
 			if (search_access(words[i], X_OK, (int *) 0) >= 0) {
+#else /* DEBIAN */ /* patch from OpenBSD */
+			staterr = 0;
+			if ((search_access(words[i], X_OK, &staterr) >= 0)
+			    || (staterr == EISDIR)) {
+#endif				
 				words[j] = words[i];
 				if (!(flags & XCF_FULLPATH))
 					memmove(words[j], words[j] + pathlen,
@@ -1018,4 +1075,42 @@
 	Xfree(xs, xp);
 }
 
+#ifdef DEBIAN /* patch from OpenBSD */  
+/*
+ * if argument string contains any special characters, they will
+ * be escaped and the result will be put into edit buffer by
+ * keybinding-specific function
+ */
+int
+x_escape(s, len, putbuf_func)
+	const char *s;
+	size_t len;
+	int putbuf_func ARGS((const char *s, size_t len));
+{
+	size_t add, wlen;
+	const char *ifs = str_val(local("IFS", 0));
+	int rval=0;
+
+	for (add = 0, wlen = len; wlen - add > 0; add++) {
+		if (strchr("\\$(){}*&;#|<>\"'`", s[add]) || strchr(ifs, s[add])) {
+			if (putbuf_func(s, add) != 0) {
+				rval = -1;
+				break;
+			}
+
+			putbuf_func("\\", 1);
+			putbuf_func(&s[add], 1);
+
+			add++;
+			wlen -= add;
+			s += add;
+			add = -1; /* after the increment it will go to 0 */
+		}
+	}
+	if (wlen > 0 && rval == 0)
+		rval = putbuf_func(s, wlen);
+
+	return (rval);
+}
+#endif /* DEBIAN */
 #endif /* EDIT */
--- pdksh-5.2.14.orig/edit.h
+++ pdksh-5.2.14/edit.h
@@ -55,6 +55,9 @@
 int	x_longest_prefix ARGS((int nwords, char *const *words));
 int	x_basename ARGS((const char *s, const char *se));
 void	x_free_words ARGS((int nwords, char **words));
+#ifdef DEBIAN /* patch from OpenBSD */ 
+int	x_escape ARGS((const char *, size_t, int (*)(const char *s, size_t len)));
+#endif /* DEBIAN */
 /* emacs.c */
 int 	x_emacs		ARGS((char *buf, size_t len));
 void 	x_init_emacs	ARGS((void));
--- pdksh-5.2.14.orig/emacs.c
+++ pdksh-5.2.14/emacs.c
@@ -138,6 +138,10 @@
 static int	x_e_getc    ARGS((void));
 static void	x_e_putc    ARGS((int c));
 static void	x_e_puts    ARGS((const char *s));
+#ifdef DEBIAN /* patch from OpenBSD */ 
+static int	x_comment   ARGS((int c));
+static int	x_emacs_putbuf	ARGS((const char *s, size_t len));
+#endif /* DEBIAN */
 static int	x_fold_case ARGS((int c));
 static char	*x_lastcp ARGS((void));
 static void	do_complete ARGS((int flags, Comp_type type));
@@ -269,6 +273,9 @@
 	{ XFUNC_transpose,		0, CTRL('T') },
 #endif
 	{ XFUNC_complete,		1, CTRL('[') },
+#ifdef DEBIAN /* patch from OpenBSD */ 
+	{ XFUNC_comp_list,		0, CTRL('I') },
+#endif /* DEBIAN */
         { XFUNC_comp_list,		1,	'='  },
 	{ XFUNC_enumerate,		1,	'?'  },
         { XFUNC_expand,			1,	'*'  },
@@ -313,6 +320,9 @@
 	 * entries.
 	 */
         { XFUNC_meta2,			1,	'['  },
+#ifdef DEBIAN  /* patch from OpenBSD */ 
+        { XFUNC_meta2,			1,	'O'  },
+#endif /* DEBIAN */
 	{ XFUNC_prev_com,		2,	'A'  },
 	{ XFUNC_next_com,		2,	'B'  },
 	{ XFUNC_mv_forw,		2,	'C'  },
@@ -468,6 +478,23 @@
 	return 0;
 }
 
+#ifdef DEBIAN  /* patch from OpenBSD */ 
+/*
+ * this is used for x_escape() in do_complete()
+ */
+static int
+x_emacs_putbuf(s, len)
+	const char *s;
+	size_t len;
+{
+	int rval;
+
+	if ((rval = x_do_ins(s, len)) != 0)
+		return (rval);
+	return (rval);
+}
+
+#endif /* DEBIAN */
 static int
 x_del_back(c)
 	int c;
@@ -1485,7 +1512,11 @@
 		for (j = 0; j < X_TABSZ; j++)
 			x_tab[i][j] = XFUNC_error;
 	for (i = 0; i < NELEM(x_defbindings); i++)
+#ifndef DEBIAN
 		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+		x_tab[(unsigned char)x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
+#endif /* DEBIAN */
 			= x_defbindings[i].xdb_func;
 
 	x_atab = (char *(*)[X_TABSZ]) alloc(sizeofN(*x_atab, X_NTABS), AEDIT);
@@ -1754,6 +1785,7 @@
 	int flags;	/* XCF_{COMMAND,FILE,COMMAND_FILE} */
 	Comp_type type;
 {
+#ifndef DEBIAN
 	char **words;
 	int nwords = 0;
 	int start, end;
@@ -1828,8 +1860,13 @@
 			if (nlen > 0) {
 				x_goto(xbuf + start);
 				x_delete(end - start, FALSE);
+#ifndef DEBIAN
 				words[0][nlen] = '\0';
 				x_ins(words[0]);
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+				x_escape(words[0], nlen, x_emacs_putbuf);
+				x_adjust();
+#endif /* DEBIAN */
 				/* If single match is not a directory, add a
 				 * space to the end...
 				 */
@@ -1841,6 +1878,54 @@
 		}
 		break;
 	}
+#else /* patch from OpenBSD */
+	char **words;
+	int nwords;
+	int start, end, nlen, olen;
+	int is_command;
+	int completed = 0;
+
+	nwords = x_cf_glob(flags, xbuf, xep - xbuf, xcp - xbuf,
+			    &start, &end, &words, &is_command);
+	/* no match */
+	if (nwords == 0) {
+		x_e_putc(BEL);
+		return;
+	}
+
+	if (type == CT_LIST) {
+		x_print_expansions(nwords, words, is_command);
+		x_redraw(0);
+		x_free_words(nwords, words);
+		return;
+	}
+
+	olen = end - start;
+	nlen = x_longest_prefix(nwords, words);
+	/* complete */
+	if (nlen > olen) {
+		x_goto(xbuf + start);
+		x_delete(olen, FALSE);
+		x_escape(words[0], nlen, x_emacs_putbuf);
+		x_adjust();
+		completed = 1;
+	}
+	/* add space if single non-dir match */
+	if ((nwords == 1) && (!ISDIRSEP(words[0][nlen - 1]))) {
+		x_ins(space);
+		completed = 1;
+	}
+
+	if (type == CT_COMPLIST && !completed) {
+		x_print_expansions(nwords, words, is_command);
+		completed = 1;
+	}
+
+	if (completed)	
+		x_redraw(0);	
+
+	x_free_words(nwords, words);
+#endif	/* DEBIAN */
 }
 
 /* NAME:
--- pdksh-5.2.14.orig/eval.c
+++ pdksh-5.2.14/eval.c
@@ -627,7 +627,7 @@
 #endif /* BRACE_EXPAND */
 				  case '=':
 					/* Note first unquoted = for ~ */
-					if (!(f & DOTEMP_) && !saw_eq) {
+					if (!(f & DOTEMP_) && !saw_eq && (f & DOASNTILDE)) {
 						saw_eq = 1;
 						tilde_ok = 1;
 					}
@@ -870,8 +870,11 @@
 		openpipe(pv);
 		shf = shf_fdopen(pv[0], SHF_RD, (struct shf *) 0);
 		ofd1 = savefd(1, 0);	/* fd 1 may be closed... */
-		ksh_dup2(pv[1], 1, FALSE);
-		close(pv[1]);
+		if (pv[1] != 1) {
+			ksh_dup2(pv[1], 1, FALSE);
+			close(pv[1]);
+		}
+		
 		execute(t, XFORK|XXCOM|XPIPEO);
 		restfd(1, ofd1);
 		startlast();
--- pdksh-5.2.14.orig/exec.c
+++ pdksh-5.2.14/exec.c
@@ -228,8 +241,10 @@
 		e->savefd[1] = savefd(1, 0);
 
 		openpipe(pv);
-		ksh_dup2(pv[0], 0, FALSE);
-		close(pv[0]);
+		if (pv[0] != 0) {
+			ksh_dup2(pv[0], 0, FALSE);
+			close(pv[0]);
+		}
 		coproc.write = pv[1];
 		coproc.job = (void *) 0;
 
@@ -448,18 +471,19 @@
 	int volatile flags;
 {
 	int i;
-	int rv = 0;
+	volatile int rv = 0;
 	register char *cp;
 	register char **lastp;
 	static struct op texec; /* Must be static (XXX but why?) */
 	int type_flags;
 	int keepasn_ok;
 	int fcflags = FC_BI|FC_FUNC|FC_PATH;
+	int bourne_function_call = 0;
 
 #ifdef KSH
 	/* snag the last argument for $_ XXX not the same as at&t ksh,
 	 * which only seems to set $_ after a newline (but not in
-	 * functions/dot scripts, but in interactive and scipt) -
+	 * functions/dot scripts, but in interactive and script) -
 	 * perhaps save last arg here and set it in shell()?.
 	 */
 	if (Flag(FTALKING) && *(lastp = ap)) {
@@ -544,9 +568,10 @@
 		newblock();
 		/* ksh functions don't keep assignments, POSIX functions do. */
 		if (keepasn_ok && tp && tp->type == CFUNC
-		    && !(tp->flag & FKSH))
-			type_flags = 0;
-		else
+		    && !(tp->flag & FKSH)) {
+			bourne_function_call = 1;
+ 			type_flags = 0;
+		} else
 			type_flags = LOCAL|LOCAL_COPY|EXPORT;
 	}
 	if (Flag(FEXPORT))
@@ -563,6 +588,8 @@
 				shf_flush(shl_out);
 		}
 		typeset(cp, type_flags, 0, 0, 0);
+		if (bourne_function_call && !(type_flags & EXPORT))
+			typeset(cp, LOCAL|LOCAL_COPY|EXPORT, 0, 0, 0);
 	}
 
 	if ((cp = *ap) == NULL) {
@@ -710,10 +737,12 @@
 		}
 
 #ifdef KSH
-		/* set $_ to program's full path */
-		/* setstr() can't fail here */
-		setstr(typeset("_", LOCAL|EXPORT, 0, INTEGER, 0), tp->val.s,
-		       KSH_RETURN_ERROR);
+		if (!Flag(FSH)) {
+			/* set $_ to program's full path */
+			/* setstr() can't fail here */
+			setstr(typeset("_", LOCAL|EXPORT, 0, INTEGER, 0), tp->val.s,
+			       KSH_RETURN_ERROR);
+		}
 #endif /* KSH */
 
 		if (flags&XEXEC) {
@@ -1351,6 +1380,8 @@
 				snptreef((char *) 0, 32, "%R", &iotmp), emsg);
 			return -1;
 		}
+		if (u == iop->unit)
+			return 0;		/* "dup from" == "dup to" */
 		break;
 	  }
 	}
@@ -1375,13 +1406,20 @@
 		return -1;
 	}
 	/* Do not save if it has already been redirected (i.e. "cat >x >y"). */
-	if (e->savefd[iop->unit] == 0)
-		/* c_exec() assumes e->savefd[fd] set for any redirections.
-		 * Ask savefd() not to close iop->unit - allows error messages
-		 * to be seen if iop->unit is 2; also means we can't lose
-		 * the fd (eg, both dup2 below and dup2 in restfd() failing).
-		 */
-		e->savefd[iop->unit] = savefd(iop->unit, 1);
+	if (e->savefd[iop->unit] == 0) {
+#ifdef DEBIAN /* patch from OpenBSD */
+		/* If these are the same, it means unit was previously closed */
+		if (u == iop->unit)
+			e->savefd[iop->unit] = -1;
+		else
+#endif			
+			/* c_exec() assumes e->savefd[fd] set for any redirections.
+			* Ask savefd() not to close iop->unit - allows error messages
+			* to be seen if iop->unit is 2; also means we can't lose
+			* the fd (eg, both dup2 below and dup2 in restfd() failing).
+			*/
+			e->savefd[iop->unit] = savefd(iop->unit, 1);
+	}
 
 	if (do_close)
 		close(iop->unit);
--- pdksh-5.2.14.orig/history.c
+++ pdksh-5.2.14/history.c
@@ -858,8 +858,8 @@
 		/*
 		 * check on its validity
 		 */
-		if ((int)base == -1 || *base != HMAGIC1 || base[1] != HMAGIC2) {
-			if ((int)base !=  -1)
+		if (base == MAP_FAILED || *base != HMAGIC1 || base[1] != HMAGIC2) {
+			if (base !=  MAP_FAILED)
 				munmap((caddr_t)base, hsize);
 			hist_finish();
 			unlink(hname);
@@ -893,7 +893,7 @@
 static int
 hist_count_lines(base, bytes)
 	register unsigned char *base;
-	register int bytes;
+	int bytes;
 {
 	State state = shdr;
 	register lines = 0;
@@ -1015,8 +1015,8 @@
 	register int bytes;
 {
 	State state;
-	int	lno;
-	unsigned char	*line;
+	int	lno = -1;
+	unsigned char	*line = NULL;
 
 	for (state = shdr; bytes-- > 0; base++) {
 		switch (state) {
@@ -1105,7 +1105,7 @@
 			/* someone has added some lines */
 			bytes = sizenow - hsize;
 			base = (unsigned char *)mmap(0, sizenow, PROT_READ, MAP_FLAGS, histfd, 0);
-			if ((int)base == -1)
+			if (base == MAP_FAILED)
 				goto bad;
 			new = base + hsize;
 			if (*new != COMMAND) {
--- pdksh-5.2.14.orig/io.c
+++ pdksh-5.2.14/io.c
@@ -297,11 +297,12 @@
 
 	if (fd < FDBASE) {
 		nfd = ksh_dupbase(fd, FDBASE);
-		if (nfd < 0)
+		if (nfd < 0) {
 			if (errno == EBADF)
 				return -1;
 			else
 				errorf("too many files open in shell");
+		}
 		if (!noclose)
 			close(fd);
 	} else
@@ -318,7 +319,7 @@
 		shf_flush(&shf_iob[fd]);
 	if (ofd < 0)		/* original fd closed */
 		close(fd);
-	else {
+	else if (fd != ofd) {
 		ksh_dup2(ofd, fd, TRUE); /* XXX: what to do if this fails? */
 		close(ofd);
 	}
@@ -502,7 +503,9 @@
 	Temp_type type;
 	struct temp **tlist;
 {
+#ifndef DEBIAN
 	static unsigned int inc;
+#endif	
 	struct temp *tp;
 	int len;
 	int fd;
@@ -516,6 +519,14 @@
 	tp->name = path = (char *) &tp[1];
 	tp->shf = (struct shf *) 0;
 	tp->type = type;
+#ifdef DEBIAN  /* based on patch from OpenBSD */ 
+	shf_snprintf(path, len, "%s/kshXXXXXX", dir);
+	fd = mkstemp(path);
+	if (fd >= 0)
+		tp->shf = shf_fdopen(fd, SHF_WR, (struct shf *) 0);
+	if (fd >= 0)
+		fchmod(fd, 0600);	
+#else /* DEBIAN */
 	while (1) {
 		/* Note that temp files need to fit 8.3 DOS limits */
 		shf_snprintf(path, len, "%s/sh%05u.%03x",
@@ -542,6 +553,7 @@
 			break;
 	}
 	tp->next = NULL;
+#endif /* DEBIAN */
 	tp->pid = procpid;
 
 	tp->next = *tlist;
--- pdksh-5.2.14.orig/lex.c
+++ pdksh-5.2.14/lex.c
@@ -645,11 +645,12 @@
 		if (c == c2 || (c == '<' && c2 == '>')) {
 			iop->flag = c == c2 ?
 				  (c == '>' ? IOCAT : IOHERE) : IORDWR;
-			if (iop->flag == IOHERE)
+			if (iop->flag == IOHERE) {
 				if ((c2 = getsc()) == '-')
 					iop->flag |= IOSKIP;
 				else
 					ungetsc(c2);
+			}
 		} else if (c2 == '&')
 			iop->flag = IODUP | (c == '<' ? IORDUP : 0);
 		else {
@@ -699,11 +700,13 @@
 
 		  case '(':  /*)*/
 #ifdef KSH
-			if ((c2 = getsc()) == '(') /*)*/
-				/* XXX need to handle ((...); (...)) */
-				c = MDPAREN;
-			else
-				ungetsc(c2);
+			if (!Flag(FSH)) {
+				if ((c2 = getsc()) == '(') /*)*/
+					/* XXX need to handle ((...); (...)) */
+					c = MDPAREN;
+				else
+					ungetsc(c2);
+			}				
 #endif /* KSH */
 			return c;
 		  /*(*/
@@ -1119,7 +1122,7 @@
 		 */
 		{
 			struct shf *shf;
-			char *ps1;
+			char * volatile ps1;
 			Area *saved_atemp;
 
 			ps1 = str_val(global("PS1"));
--- pdksh-5.2.14.orig/main.c
+++ pdksh-5.2.14/main.c
@@ -201,7 +201,24 @@
 	change_flag(FPOSIX, OF_SPECIAL, 1);
 #endif /* POSIXLY_CORRECT */
 
-	/* import enviroment */
+#ifdef DEBIAN /* patch from OpenBSD */
+	/* Check to see if we're /bin/sh. */
+	if (!strcmp(&kshname[strlen(kshname) - 3], "/sh")
+	    || !strcmp(kshname, "sh") || !strcmp(kshname, "-sh"))
+		Flag(FSH) = 1;
+
+	/* Set edit mode to emacs by default, may be overridden
+	* by the environment or the user.  Also, we want tab completion
+	* on in vi by default. */
+#if defined(EDIT) && defined(EMACS)
+	change_flag(FEMACS, OF_SPECIAL, 1);
+#endif /* EDIT && EMACS */
+	#if defined(EDIT) && defined(VI)
+	Flag(FVITABCOMPLETE) = 1;
+#endif /* EDIT && VI */
+#endif /* DEBIAN */
+		
+	/* import environment */
 	if (environ != NULL)
 		for (wp = environ; *wp != NULL; wp++)
 			typeset(*wp, IMPORT|EXPORT, 0, 0, 0);
@@ -576,11 +593,12 @@
 		if (trap)
 			runtraps(0);
 
-		if (s->next == NULL)
+		if (s->next == NULL) {
 			if (Flag(FVERBOSE))
 				s->flags |= SF_ECHO;
 			else
 				s->flags &= ~SF_ECHO;
+		}
 
 		if (interactive) {
 			j_notify();
--- pdksh-5.2.14.orig/misc.c
+++ pdksh-5.2.14/misc.c
@@ -159,6 +159,7 @@
 	{ "posix",	  0,		OF_ANY }, /* non-standard */
 	{ "privileged",	'p',		OF_ANY },
 	{ "restricted",	'r',	    OF_CMDLINE },
+	{ "sh",		  0,		OF_ANY }, /* non-standard */ /* from OpenBSD */
 	{ "stdin",	's',	    OF_CMDLINE }, /* pseudo non-standard */
 	{ "trackall",	'h',		OF_ANY },
 	{ "verbose",	'v',		OF_ANY },
@@ -309,8 +310,15 @@
 #ifdef OS2
 		;
 #else /* OS2 */
+#ifndef DEBIAN
 		setuid(ksheuid = getuid());
 		setgid(getgid());
+#else /* patch from OpenBSD */
+		seteuid(ksheuid = getuid());
+		setuid(ksheuid);
+		setegid(getgid());
+		setgid(getgid());
+#endif /* DEBIAN */
 #endif /* OS2 */
 	} else if (f == FPOSIX && newval) {
 #ifdef BRACE_EXPAND
@@ -471,6 +479,7 @@
 	const char *as;
 	int *ai;
 {
+#ifndef DEBIAN
 	const char *s;
 	register int n;
 	int sawdigit = 0;
@@ -484,6 +493,19 @@
 	if (*s || !sawdigit)
 		return 0;
 	return 1;
+#else /* patch from OpenBSD */
+	char *p;
+	long n;
+
+	n = strtol(as, &p, 10);
+
+	if (!*as || *p || INT_MIN >= n || n >= INT_MAX)
+		return 0;
+
+	*ai = (int)n;
+	return 1;
+#endif
+	
 }
 
 /* getn() that prints error */
--- pdksh-5.2.14.orig/sh.h
+++ pdksh-5.2.14/sh.h
@@ -382,7 +382,11 @@
  */
 
 typedef struct Area {
+#ifndef DEBIAN
 	struct Block *freelist;	/* free list */
+#else /* patch from OpenBSD */	
+	struct link *freelist;  /* free list */
+#endif
 } Area;
 
 EXTERN	Area	aperm;		/* permanent object space */
@@ -501,6 +505,7 @@
 	FPOSIX,		/* -o posix: be posixly correct */
 	FPRIVILEGED,	/* -p: use suid_profile */
 	FRESTRICTED,	/* -r: restricted shell */
+	FSH,		/* -o sh: favor sh behavour */
 	FSTDIN,		/* -s: (invocation) parse stdin */
 	FTRACKALL,	/* -h: create tracked aliases for all commands */
 	FVERBOSE,	/* -v: echo input */
--- pdksh-5.2.14.orig/table.c
+++ pdksh-5.2.14/table.c
@@ -53,7 +53,7 @@
 	if (otblp == NULL)
 		return;
 	for (i = 0; i < osize; i++)
-		if ((tblp = otblp[i]) != NULL)
+		if ((tblp = otblp[i]) != NULL) {
 			if ((tblp->flag&DEFINED)) {
 				for (p = &ntblp[hash(tblp->name)
 					  & (tp->size-1)];
@@ -65,6 +65,7 @@
 			} else if (!(tblp->flag & FINUSE)) {
 				afree((void*)tblp, tp->areap);
 			}
+		}
 	afree((void*)otblp, tp->areap);
 }
 
--- pdksh-5.2.14.orig/trap.c
+++ pdksh-5.2.14/trap.c
@@ -68,6 +68,8 @@
 alarm_catcher(sig)
 	int sig;
 {
+	int errno_ = errno;
+	
 	if (ksh_tmout_state == TMOUT_READING) {
 		int left = alarm(0);
 
@@ -77,6 +79,7 @@
 		} else
 			alarm(left);
 	}
+	errno = errno_;
 	return RETSIGVAL;
 }
 #endif /* KSH */
@@ -111,6 +114,7 @@
 	int i;
 {
 	Trap *p = &sigtraps[i];
+	int errno_ = errno;
 
 	trap = p->set = 1;
 	if (p->flags & TF_DFL_INTR)
@@ -125,6 +129,7 @@
 	if (sigtraps[i].cursig == trapsig) /* this for SIGCHLD,SIGALRM */
 		sigaction(i, &Sigact_trap, (struct sigaction *) 0);
 #endif /* V7_SIGNALS */
+	errno = errno_;
 	return RETSIGVAL;
 }
 
--- pdksh-5.2.14.orig/tree.c
+++ pdksh-5.2.14/tree.c
@@ -506,7 +506,7 @@
 		for (tw = t->vars; *tw++ != NULL; )
 			;
 		rw = r->vars = (char **)
-			alloc((int)(tw - t->vars) * sizeof(*tw), ap);
+			alloc((tw - t->vars + 1) * sizeof(*tw), ap);
 		for (tw = t->vars; *tw != NULL; )
 			*rw++ = wdcopy(*tw++, ap);
 		*rw = NULL;
@@ -518,7 +518,7 @@
 		for (tw = t->args; *tw++ != NULL; )
 			;
 		rw = r->args = (char **)
-			alloc((int)(tw - t->args) * sizeof(*tw), ap);
+			alloc((tw - t->args + 1) * sizeof(*tw), ap);
 		for (tw = t->args; *tw != NULL; )
 			*rw++ = wdcopy(*tw++, ap);
 		*rw = NULL;
@@ -679,7 +679,7 @@
 
 	for (ior = iow; *ior++ != NULL; )
 		;
-	ior = (struct ioword **) alloc((int)(ior - iow) * sizeof(*ior), ap);
+	ior = (struct ioword **) alloc((ior - iow + 1) * sizeof(*ior), ap);
 
 	for (i = 0; iow[i] != NULL; i++) {
 		register struct ioword *p, *q;
--- pdksh-5.2.14.orig/var.c
+++ pdksh-5.2.14/var.c
@@ -63,11 +63,12 @@
 
 	e->loc = l->next;	/* pop block */
 	for (i = l->vars.size; --i >= 0; )
-		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL))
+		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL)) {
 			if ((vq = global(vp->name))->flag & ISSET)
 				setspec(vq);
 			else
 				unsetspec(vq);
+		}
 	if (l->flags & BF_DOGETOPTS)
 		user_opt = l->getopts_state;
 	afreeall(&l->area);
@@ -217,11 +218,12 @@
 	}
 	for (l = e->loc; ; l = l->next) {
 		vp = tsearch(&l->vars, n, h);
-		if (vp != NULL)
+		if (vp != NULL) {
 			if (array)
 				return arraysearch(vp, val);
 			else
 				return vp;
+		}
 		if (l->next == NULL)
 			break;
 	}
--- pdksh-5.2.14.orig/vi.c
+++ pdksh-5.2.14/vi.c
@@ -63,6 +63,9 @@
 static void	vi_pprompt ARGS((int full));
 static void	vi_error ARGS((void));
 static void	vi_macro_reset ARGS((void));
+#ifdef DEBIAN   /* patch from OpenBSD */ 
+static int	x_vi_putbuf	ARGS((const char *s, size_t len));
+#endif /* DEBIAN */
 
 #define C_	0x1		/* a valid command that isn't a M_, E_, U_ */
 #define M_	0x2		/* movement command (h, l, etc.) */
@@ -235,7 +238,7 @@
 
 	x_putc('\r'); x_putc('\n'); x_flush();
 
-	if (c == -1)
+	if (c == -1 || len <= es->linelen)
 		return -1;
 
 	if (es->cbuf != buf)
@@ -459,15 +462,22 @@
 			else {
 				locpat[srchlen++] = ch;
 				if ((ch & 0x80) && Flag(FVISHOW8)) {
+					if (es->linelen + 2 > es->cbufsize)
+						vi_error();
 					es->cbuf[es->linelen++] = 'M';
 					es->cbuf[es->linelen++] = '-';
 					ch &= 0x7f;
 				}
 				if (ch < ' ' || ch == 0x7f) {
+					if (es->linelen + 2 > es->cbufsize)
+						vi_error();
 					es->cbuf[es->linelen++] = '^';
 					es->cbuf[es->linelen++] = ch ^ '@';
-				} else
+				} else {
+					if (es->linelen >= es->cbufsize)
+						vi_error();
 					es->cbuf[es->linelen++] = ch;
+				}
 				es->cursor = es->linelen;
 				refresh(0);
 			}
@@ -690,7 +700,7 @@
 	/* End nonstandard vi commands } */
 
 	default:
-		if (es->linelen == es->cbufsize - 1)
+		if (es->linelen >= es->cbufsize - 1)
 			return -1;
 		ibuf[inslen++] = ch;
 		if (insert == INSERT) {
@@ -1403,7 +1413,7 @@
 	new = (struct edstate *)alloc(sizeof(struct edstate), APERM);
 	new->cbuf = alloc(old->cbufsize, APERM);
 	new->cbufsize = old->cbufsize;
-	strcpy(new->cbuf, old->cbuf);
+ 	memcpy(new->cbuf, old->cbuf, old->linelen);
 	new->linelen = old->linelen;
 	new->cursor = old->cursor;
 	new->winleft = old->winleft;
@@ -1414,7 +1424,7 @@
 restore_edstate(new, old)
 	struct edstate *old, *new;
 {
-	strncpy(new->cbuf, old->cbuf, old->linelen);
+	memcpy(new->cbuf, old->cbuf, old->linelen);
 	new->linelen = old->linelen;
 	new->cursor = old->cursor;
 	new->winleft = old->winleft;
@@ -1470,6 +1480,19 @@
 	holdlen = 0;
 }
 
+#ifdef DEBIAN /* patch from OpenBSD */ 
+/*
+ * this is used for calling x_escape() in complete_word()
+ */
+static int
+x_vi_putbuf(s, len)
+	const char *s;
+	size_t len;
+{
+	return putbuf(s, len, 0);
+}
+
+#endif /* DEBIAN */
 static int
 putbuf(buf, len, repl)
 	const char *buf;
@@ -1965,7 +1988,11 @@
 	del_range(start, end);
 	es->cursor = start;
 	for (i = 0; i < nwords; ) {
+#ifndef DEBIAN
 		if (putbuf(words[i], (int) strlen(words[i]), 0) != 0) {
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+		if (x_escape(words[i], strlen(words[i]), x_vi_putbuf) != 0) {
+#endif /* DEBIAN */
 			rval = -1;
 			break;
 		}
@@ -2068,9 +2095,18 @@
 	buf = save_edstate(es);
 	del_range(start, end);
 	es->cursor = start;
+#ifndef DEBIAN
 	if (putbuf(match, match_len, 0) != 0)
 		rval = -1;
 	else if (is_unique) {
+#else /* DEBIAN */ /* patch from OpenBSD */ 
+
+	/* escape all shell-sensitive characters and put the result into
+	 * command buffer */
+	rval = x_escape(match, match_len, x_vi_putbuf);
+
+	if (rval == 0 && is_unique) {
+#endif /* DEBIAN */
 		/* If exact match, don't undo.  Allows directory completions
 		 * to be used (ie, complete the next portion of the path).
 		 */
--- pdksh-5.2.14.orig/debian/.cvsignore
+++ pdksh-5.2.14/debian/.cvsignore
@@ -0,0 +1,5 @@
+pdksh
+_tmp_
+*debhelper
+files
+*substvars
--- pdksh-5.2.14.orig/debian/changelog
+++ pdksh-5.2.14/debian/changelog
@@ -0,0 +1,229 @@
+pdksh (5.2.14-11) unstable; urgency=low
+
+  * Compile with _FILE_OFFSET_BITS=64 to support files larger than 2GB
+    (closes: #237038).
+
+ -- Robert Luberda <robert@debian.org>  Thu, 25 Mar 2004 01:11:05 +0100
+
+pdksh (5.2.14-10) unstable; urgency=low
+
+  * More patches from OpenBSD:
+    + vi.c: Buffers are not strings so use memcpy(), not strlcpy() to copy
+      them. Also add some further bounds checks in the name of paranoia.
+    + exec.c: Unbreak parameter assignment when calling bourne style
+      functions.
+    + exec.c: For the >& and <& operators, add a check for "dup from" ==
+      "dup to" and just return success if they are the same.  Fixes the
+      "ls 2>&2" problem.
+    + eval.c, exec.c, io.c, jobs.c: If "from fd" == "to fd" don't call
+      dup2() or close "from fd".
+
+ -- Robert Luberda <robert@debian.org>  Mon, 19 Jan 2004 21:35:40 +0100
+
+pdksh (5.2.14-9) unstable; urgency=low
+
+  * More patches from OpenBSD:
+    + c_test.c: The special case code for "test -x" over NFS was
+      incorrect.  The right thing to do is to try access(2) first
+      (since that occurs on the NFS server side) and only check for the
+      absence of an execute bit when access(2) succeeds.
+    + edit.c: in word location, fix forward scanning so it correctly
+      account for any escaped char and not only spaces.  for "foo
+      (bar.a)" and "foo (bar a)", cd foo\ \(bar.<tab> will correctly
+      expand to foo\ \(bar.a\).
+    + alloc.c: Don't allow alloc() and aresize() to fail.  Their return 
+      value was only checked in two place (both in conjunction with 
+      str_save).  Upon malloc/realloc failure we call internal_errorf()
+      which pops throws and error and pops back to the last good state.	
+  * Standards-Version: 3.6.1 (no changes).
+
+ -- Robert Luberda <robert@debian.org>  Tue, 14 Oct 2003 21:10:23 +0200
+
+pdksh (5.2.14-8) unstable; urgency=low
+
+  * Don't do tilde expansion after `=' sign in non-assignments.
+    Patch stolen from the posh package (closes: #187839).
+  * Fix typo in man page (closes: #188335).
+  * Handle DEB_BUILD_OPTIONS=noopt instead of debug.
+  * Standards-Version: 3.5.9.
+  * Refer to common-licenses/GPL in the copyright file (lintian).
+  * Fix typo in package description.
+
+ -- Robert Luberda <robert@debian.org>  Wed, 23 Apr 2003 22:20:52 +0200
+
+pdksh (5.2.14-7) unstable; urgency=low
+
+  * Merge many patches from OpenBSD:
+    + Introduce FSH flag, which is set when the shell is called as `sh'.
+    + alloc.c: Kill hand-made memory allocation code, that is definitely
+      buggy. Replace with simple wrapper around malloc, at least this works,
+      and it's easier to debug anyways.
+    + tree.c: Fix three off-by-one errors.
+    + c_sh.c: don't set close-on-exec flag on file descriptors in FSH mode
+      (closes: #154540). Documented the change in ksh(1).
+    + history.c: Compare the return from mmap with MAP_FAILED, do not cast it
+      to int and compare with -1.
+    + main.c: set edit mode to emacs by default, may be overridden by the
+      environment or the user.  Also, we want tab completion in vi by default.
+    + misc.c: use strtol() in getn().
+    + emacs.c:
+       - bind TAB (^I) to complete-list by default
+       - complete-list first completes; if that does not work, it lists
+       - fix a memleak in do_complete()
+    + edit.c:
+       - completion now works after '=' (dd), and ':' (ssh) and ` (backtick)
+       - add '#' to the list of escaped characters during vi/emacs filename
+         completion
+
+  * exec.c: Found and fixed yet another problem with `set -e' scripts
+    (see a changelog entry for 5.2.14-3), which caused `dpkg-buildpackage -B'
+    to fail on systems where /bin/sh is ksh.
+
+  * c_sh.c: Make `set' command return 0 always, not only in the POSIX mode.
+    According to Jeff Sheinberg <jeffsh@localnet.com>, this new behaviour
+    is more compatible with SUSv2 standard and other shells (esp. ksh93)
+    (closes: #118476). Documented the change in ksh(1) man page.
+
+  * Fixed -Wall warnings.
+  * ksh.Man: fixed some typos in the manpage, patch based on NetBSD.
+  * tests/th: corrected path to perl.
+  * debian/copyright: include copyright for alloc.c.
+  * debian/rules: Switch to debhelper v4.
+  * Removed emacs settings from the bottom of this file.
+
+ -- Robert Luberda <robert@debian.org>  Wed, 28 Aug 2002 23:40:00 +0200
+
+pdksh (5.2.14-6) unstable; urgency=low
+
+  * Corrected spelling in package description (closes: #125223).
+
+ -- Robert Luberda <robert@debian.org>  Sat, 22 Dec 2001 21:53:51 +0100
+
+pdksh (5.2.14-5) unstable; urgency=low
+
+  * Apply three patches from PLD distribution (pdksh-5.2.14-23.src.rpm)
+     + pdksh-awful-free-bug.patch, fixes segfault bug (closes: #95229)
+     + pdksh-eval-segv.patch, fixes one more segfault bug
+     + pdksh-rlimit_locks.patch, adds flocks support to ulimit.
+
+  * Standards-Version: 3.5.6 (no changes).
+  * Change pdksh package priority to "optional".
+  * Minor fixes in ksh(1) manpage.
+
+ -- Robert Luberda <robert@debian.org>  Wed,  3 Oct 2001 23:10:46 +0200
+
+pdksh (5.2.14-4) unstable; urgency=low
+
+  * Do not install /usr/bin/ksh -> /bin/ksh symlink on Hurd.
+  * debian/rules: update to the newset debhelper.
+  * Compiled with -Wall, fixed some gcc warnings.
+  * Standards-Version: 3.5.5.
+
+ -- Robert Luberda <robert@debian.org>  Thu, 14 Jun 2001 22:49:51 +0200
+
+pdksh (5.2.14-3) unstable; urgency=low
+
+  * Applied patch from upstream author which fixed problem with 'set -e'
+    (closes: #71256).
+  * Applied some patches from OpenBSD:
+     - use mkstemp to create temporary files	
+     - kill -s now works
+     - escapes special characters in tab completitions
+  * Standards-Version: 3.5.0 (no changes).
+  * Included BUG-REPORTS and PROJECTS files in binary package.
+
+ -- Robert Luberda <robert@debian.org>  Mon, 12 Feb 2001 07:06:08 +0100
+
+pdksh (5.2.14-2) unstable; urgency=low
+
+  * New maintainer (closes: #82488).
+  * Applied patch from upstream ftp site to fix problem with readonly
+    variables (closes: #57727).
+  * Repackaged with debhelper v3.
+  * Updated standards version to 3.2.1 (FHS, Build-Depends).
+  * Corrected & updated the copyright file (closes: #64195).
+  * Moved ksh to /bin and made symlink from /usr/bin (closes: #70531, #74600).
+  * Added examples directory with ksh.kshrc and profile.
+
+ -- Robert Luberda <robert@debian.org>  Wed, 17 Jan 2001 22:38:04 +0100
+
+pdksh (5.2.14-1) unstable; urgency=low
+
+  * New upstream version (#44790)
+
+ -- Mark Baker <mbaker@iee.org>  Fri, 24 Sep 1999 22:25:17 +0100
+
+pdksh (5.2.13-5) unstable; urgency=low
+
+  * trap.c: Applied patch from ashcroft@mround.bt.co.uk to fix SEGV when 
+    starting on sparc, alpha and powerpc (#30536,#33988,#35473,#40740)
+
+ -- Mark Baker <mbaker@iee.org>  Sun,  4 Jul 1999 23:14:19 +0100
+
+pdksh (5.2.13-4) unstable; urgency=low
+
+  * Use simple history instead of complex history. One person requested this 
+  change, and no-one spoke out against it, so I'm doing it. Basically, complex
+  history is newer and will be better, but is not fully implemented yet.
+  (#23929)
+
+ -- Mark Baker <mbaker@iee.org>  Thu,  3 Dec 1998 21:45:03 +0000
+
+pdksh (5.2.13-3) unstable; urgency=low
+
+  * Rewritten copyright file
+
+ -- Mark Baker <mbaker@iee.org>  Sat, 07 Mar 1997 22:25:37 +0000
+
+pdksh (5.2.13-2) unstable; urgency=low
+
+  * Updated standards-version to 2.4.0.0 (no changes)
+
+ -- Mark Baker <mbaker@iee.org>  Sun, 16 Nov 1997 17:37:57 +0000
+
+pdksh (5.2.13-1) unstable; urgency=low
+
+  * New upstream version (fixes #5510)
+
+ -- Mark Baker <mbaker@iee.org>  Sun, 16 Nov 1997 17:37:57 +0000
+
+pdksh (5.2.12-4) unstable; urgency=low
+
+  * Er, this time it should really be a new maintainer. I forgot to change 
+  the control file last time :)
+
+ -- Mark Baker <mbaker@iee.org>  Sun, 13 Jul 1997 20:21:41 +0100
+
+pdksh (5.2.12-3) unstable; urgency=low
+
+  * New maintainer
+  * Compiled for libc6
+
+ -- Mark Baker <mbaker@iee.org>  Wed, 18 Jun 1997 13:22:34 +0100
+
+pdksh (5.2.12-2) unstable; urgency=low
+
+  * Rebuilt package to fix shlibs problem (no changes to source package)
+    (Fixes Bugs #5240, #5241, #5242)
+ -- Larry Daffner <vizzie@airmail.net>  Sun, 3 Nov 1996 19:26:14 -0600
+
+pdksh (5.2.12-1) unstable; urgency=low
+
+  * New upstream version
+  * Fixes bug#4881
+
+ -- Larry Daffner <vizzie@airmail.net>  Tue, 29 Oct 1996 23:44:02 -0600
+
+pdksh (5.2.11-1) unstable; urgency=low
+
+  * New upstream version (5.2.10 was not packaged for Debian)
+
+ -- Larry Daffner <vizzie@airmail.net>  Sun, 20 Oct 1996 23:31:13 -0500
+
+pdksh (5.2.9-1) unstable; urgency=low
+
+  * New maintainer
+  * New upstream version
+  * Changed to new source format
+
+ -- Larry Daffner <vizzie@airmail.net>  Wed, 2 Oct 1996 23:52:34 -0500
--- pdksh-5.2.14.orig/debian/compat
+++ pdksh-5.2.14/debian/compat
@@ -0,0 +1 @@
+4
--- pdksh-5.2.14.orig/debian/control
+++ pdksh-5.2.14/debian/control
@@ -0,0 +1,20 @@
+Source: pdksh
+Section: shells
+Priority: optional
+Maintainer: Robert Luberda <robert@debian.org>
+Build-Depends: debhelper (>= 4.1.70)
+Standards-Version: 3.6.1
+
+Package: pdksh
+Architecture: any
+Depends: ${shlibs:Depends}
+Description: A public domain version of the Korn shell
+ PD-ksh is a mostly complete AT&T ksh look-alike (see NOTES file for a list
+ of things not supported).  Work is currently underway to make it fully
+ compatible with both POSIX and AT&T ksh (when the two don't conflict).
+ .
+ Since pdksh is free and compiles and runs on most common Unix systems,
+ it is very useful in creating a consistent user interface across multiple
+ machines.  For example, in the CS department of MUN, pdksh is installed
+ on a variety of machines including Suns, HPs, DecStations, PCs running
+ Linux, etc., and is the login shell of ~4500 users.
--- pdksh-5.2.14.orig/debian/copyright
+++ pdksh-5.2.14/debian/copyright
@@ -0,0 +1,82 @@
+This is the GNU/Linux prepackaged version of pdksh, a public domain clone
+of the AT&T Korn shell..
+
+This Debian package is currently maintained by Robert Luberda <robert@debian.org>
+It was put together from sources obtained from:
+
+        ftp://ftp.cs.mun.ca/pub/pdksh/pdksh-5.2.14.tar.gz
+
+Former maintainers were Mark Baker, Larry Daffner, Martin Schulze 
+and Ian Murdock.
+
+PDksh itself is currently being maintained by Michael Rendell
+(michael@cs.mun.ca), who took over from Simon J. Gerraty
+(sjg@zen.void.oz.au) at the later's suggestion.
+
+
+pdksh is provided AS IS, with NO WARRANTY, either expressed or implied.
+
+The vast majority of the code that makes pdksh is in the public domain.
+The exceptions are:
+
+        sigact.c and sigact.h
+                These are covered with copyright by Simon J. Gerraty;
+                the copyright notice for these files is as follows:
+                    This is free software.  It comes with NO WARRANTY.
+                    Permission to use, modify and distribute this source code
+                    is granted subject to the following conditions.
+                    1/ that that the above copyright notice and this notice 
+                    are preserved in all copies and that due credit be given 
+                    to the author.  
+                    2/ that any changes to this code are clearly commented 
+                    as such so that the author does get blamed for bugs 
+                    other than his own.
+
+        aclocal.m4
+                This is covered by the GNU General Public Licence (GPL)
+                as it contains modified versions of macros that come with
+                GNU autoconf.  As this is used solely for configuration,
+                the pdksh code itself is not covered by the GPL.
+                The following is taken from autoconf 2.x documentation
+                (info autoconf questions distributing) concerning use
+                of autoconf in programs:
+
+                   There are no restrictions on how the configuration
+                   scripts that Autoconf produces may be distributed
+                   or used.  In Autoconf version 1, they were covered by
+                   the GNU General Public License.  We still encourage
+                   software authors to distribute their work under terms
+                   like those of the GPL, but doing so is not required
+                   to use Autoconf.
+                
+                On Debian systems the full text of the GPL license can
+                be found in the /usr/share/common-licenses file.
+
+
+
+File alloc.c, which was taken from the OpenBSD project, is copyrighted
+as follows:
+
+        Copyright (c) 2002 Marc Espie.
+       
+        Redistribution and use in source and binary forms, with or without
+        modification, are permitted provided that the following conditions
+        are met:
+        1. Redistributions of source code must retain the above copyright
+           notice, this list of conditions and the following disclaimer.
+        2. Redistributions in binary form must reproduce the above copyright
+           notice, this list of conditions and the following disclaimer in the
+           documentation and/or other materials provided with the distribution.
+       
+        THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
+        ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+        A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
+        PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
--- pdksh-5.2.14.orig/debian/docs
+++ pdksh-5.2.14/debian/docs
@@ -0,0 +1,5 @@
+NEWS
+NOTES
+BUG-REPORTS
+PROJECTS
+debian/_tmp_/changelog.0
--- pdksh-5.2.14.orig/debian/examples
+++ pdksh-5.2.14/debian/examples
@@ -0,0 +1,2 @@
+etc/profile
+etc/ksh.kshrc
--- pdksh-5.2.14.orig/debian/menu
+++ pdksh-5.2.14/debian/menu
@@ -0,0 +1,2 @@
+?package(pdksh):needs="text" section="Apps/Shells" \
+		title="Ksh" command="/bin/ksh -l"
--- pdksh-5.2.14.orig/debian/rules
+++ pdksh-5.2.14/debian/rules
@@ -0,0 +1,103 @@
+#!/usr/bin/make -f
+# Sample debian/rules that uses debhelper.
+# This file is public domain software, originally written by Joey Hess. 
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+                     CFLAGS_ADD = -O0
+else
+                     CFLAGS_ADD = -O2
+endif
+ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
+                     INSTALL_ADD = -s
+endif
+
+ifeq (,$(DEB_BUILD_ARCH))
+	DEB_BUILD_ARCH=$(shell dpkg-architecture -qDEB_BUILD_ARCH)
+endif
+
+build: build-stamp
+build-stamp:
+	dh_testdir
+
+	./configure --prefix=/ \
+		    --enable-history=simple
+
+
+	$(MAKE)  CFLAGS="-Wall -g -DDEBIAN -D_FILE_OFFSET_BITS=64 $(CFLAGS_ADD)"
+
+	touch build-stamp
+
+clean:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp
+
+	# Add here commands to clean up after the build process.
+	if [ -f Makefile ]; then \
+	  make realclean; \
+	else \
+	  make -f Makefile.in realclean; \
+	fi
+
+	rm -rf debian/_tmp_
+
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+	# Add here commands to install the package into debian/<packagename>
+	$(MAKE) LDFLAGS="" INSTALL_PROGRAM='install -c $(INSTALL_ADD)' \
+		prefix=$(CURDIR)/debian/$(shell dh_listpackages)/ \
+		mandir='$$(prefix)/usr/share/man/man1' install
+
+	mkdir -p -m755 debian/_tmp_
+	cp -a ChangeLog.0 debian/_tmp_/changelog.0
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs ChangeLog
+	dh_installdocs
+	dh_installexamples
+#	dh_install
+	dh_installmenu
+#	dh_installdebconf	
+#	dh_installlogrotate
+#	dh_installemacsen
+#	dh_installpam
+#	dh_installmime
+#	dh_installinit
+#	dh_installcron
+#	dh_installinfo
+#	dh_undocumented
+#	dh_installman
+
+ifneq (hurd,$(patsubst hurd-%,hurd,$(DEB_BUILD_ARCH)))
+	dh_link  bin/ksh usr/bin/ksh
+endif
+
+	dh_strip
+	dh_compress
+	dh_fixperms
+#	dh_makeshlibs
+	dh_installdeb
+#	dh_perl
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install
--- pdksh-5.2.14.orig/tests/th
+++ pdksh-5.2.14/tests/th
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 
 #
 # Test harness for pdksh tests.
@@ -131,7 +131,7 @@
 $os = defined $^O ? $^O : 'unknown';
 
 require 'signal.ph' unless $os eq 'os2';
-require 'errno.ph' unless $os eq 'os2';
+# require 'errno.ph' unless $os eq 'os2';
 require 'getopts.pl';
 
 ($prog = $0) =~ s#.*/##;
